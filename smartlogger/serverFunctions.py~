# -*- coding: utf-8 -*-

# Autores: Ricardo Almeida, Roger Machado

from datetime import datetime
from os import linesep
import socket
import ast
import logging

from readConfFile import ReadConfFile

from databaseConnection import DatabaseConnection
from eventDatabaseConnection import EventDatabaseConnection

# Criptografia da camada de aplicação
#from crypto import Crypto
#from Crypto.PublicKey import RSA

# Assinatura
from Crypto.Hash import MD5
from Crypto import Random

import json
import ast

class ServerFunctions:
#    crypto = None
    readConf = None
    esperTCP = None
    esperDest = None
    
    def __init__(self):
        """
        Construtor que instancia as classes WriteLog, Crypto e ReadConf
        """
        try:
            #self.crypto = Crypto.__new__(Crypto) 
            self.readConf = ReadConfFile.__new__(ReadConfFile)
            # Envia logs ao Esper
            self.esperTCP = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            
            self.esperDest = (self.readConf.esperHost, self.readConf.esperPort)    
        except Exception, e:
            logging.error('', exc_info=True)
            
    def getExpressionLogs(self):
        """
        Função utilizada para coletar as expressões de formatação de logs no banco de dados
        """
        try:
            #=====================================================================================#
            # Concatena o nome do cliente (realizando a descriptografia) com "_conf" para fazer 
            # a busca pelas configurações na tabela correta, e monta o SQL
            
            sql = "SELECT name, expression  FROM library_expression ORDER BY id_name" 

            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL e atribui o seu retorno a variável resposta
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            cur.execute(sql)
            con.commit()
            confCollect = cur.fetchall()
            
            resposta = confCollect
            
            #=====================================================================================#
        except Exception, e:
            logging.error("ERRO: Falha na leitura das" +
                                    " configurações do cliente no banco de dados: ", exc_info=True)
            resposta = False
        finally:
            cur.close()
            con.close()
            
        return str(resposta)
            
            
    def getMonitoredItems(self, clientNameEncrypted, typeEncrypted):
        """
        Função usada para capturar as informações do bando de dados, de quais itens serão analisados 
        pelo agente e retorna essas informações para o agente, caso ocorra algum erro, retorna
        False, este retorno deverá ser tratado no agente.
        """
        try:
            #=====================================================================================#
            # Concatena o nome do cliente (realizando a descriptografia) com "_conf" para fazer 
            # a busca pelas configurações na tabela correta, e monta o SQL
            clientName = str(clientNameEncrypted)
            type_ = str(typeEncrypted)
            
            if type_ == 'log':
                sql = "SELECT key_, delay, table_, filterprogram, formatcolumn, formatcolumntype,  " \
                    + " formatcolumntypedata, identifier, itemidhosts FROM items_hosts WHERE hostid=(SELECT hostid FROM hosts WHERE host='" \
                    + str(clientName) + "') AND status = 1 AND table_ is not NULL and table_ != '' ORDER BY table_";
            elif type_ == 'status':
                sql = "SELECT key_, delay, status, table_, itemid, formatcolumntypedata, identifier, itemidhosts  FROM items_hosts " \
                    + "WHERE hostid=(SELECT hostid FROM hosts WHERE host='" \
                    + str(clientName) + "') AND status = 1 AND (table_ is NULL or table_ = '') ORDER BY key_";
            elif type_ == 'syslog':
                sql = "SELECT key_, table_, filterprogram, formatcolumn, formatcolumntype, formatcolumntypedata, identifier FROM items_hosts " \
                    + "WHERE hostid=(SELECT hostid FROM hosts WHERE host='" \
                    + str(clientName) + "') AND status = 1 AND table_ is not NULL and delay = -1 " \
                    + "ORDER BY key_";
            #=====================================================================================#

            #=====================================================================================#
            # Executa o SQL e atribui o seu retorno a variável resposta
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            cur.execute(sql)
            con.commit()
            confCollect = cur.fetchall()
            
            resposta = confCollect
            #=====================================================================================#
        except Exception, e:
            logging.error("ERRO: Falha na leitura das" +
                                    " configurações do cliente no banco de dados: ", exc_info=True)
            resposta = False
        finally:
            cur.close()
            con.close()
            
        return str(resposta)
    
    def getDiscoveredItems(self, clientNameEncrypted):
        """
        Função utilizada para coletar o itens de descoberta que serão enviados para o agente que
        irá identificar as variáveis e solicitar ao servidor a criação dos novos itens
        """
        try:
            #=====================================================================================#
            # Concatena o nome do cliente (realizando a descriptografia) com "_conf" para fazer 
            # a busca pelas configurações na tabela correta, e monta o SQL
            clientName = str(clientNameEncrypted)
            
            sql = "SELECT key_, itemid, name, identifier  FROM items_hosts " \
                    + "WHERE hostid=(SELECT hostid FROM hosts WHERE host='" \
                    + str(clientName) + "') AND status = 2";

            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL e atribui o seu retorno a variável resposta
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            cur.execute(sql)
            con.commit()
            confCollect = cur.fetchall()
            
            resposta = confCollect
            
            #=====================================================================================#
        except Exception, e:
            logging.error("ERRO: Falha na leitura das" +
                                    " configurações do cliente no banco de dados: ", exc_info=True)
            resposta = False
        finally:
            cur.close()
            con.close()
            
        return str(resposta)
    
    def insertLogs(self, identifierHostname, table, formatTable, data):
        """
        Função usada para receber os logs analisados e inseri-los em suas respectivas tabelas,
        caso ocorra algum erro, retorna False, este retorno deverá ser tratado no agente.
        """
        #try:
            #=====================================================================================#
            # Descriptografa os parâmetros passados (tabela, formato da tabela e data de coleta)
           # table = str(tableEncrypted)
           # formatTable = ast.literal_eval(str(formatTableEncrypted))
	   # dataUTF = str(dataEncrypted).decode('utf-8', 'ignore').encode('utf-8')
           # data = ast.literal_eval(str(dataUTF))
           # identifierHostname = str(identifierHostnameEncrypted)
	#except Exception, e:
        #        logging.error("Falha ao receber os dados: ", exc_info=True)        
	#	logging.error("Identificador: %s, Tabela: %s, Formato da Tabela: %s, Dados: %s",
	#			str(identifierHostnameEncrypted), str(tableEncrypted), 
	#			str(formatTableEncrypted), str(dataEncrypted))
#		return False
                
        # Envia dados ao esper 
        try:
            if self.readConf.correlation:
                logEvent = "stream="+str(identifierHostname)+","
                i = 0
                while(i<len(formatTable)):
                    if formatTable[i] == 'date_coll':                
                        logEvent=logEvent+str(formatTable[i])+"="+str(data[i])+","
                    else:
                        logEvent=logEvent+str(formatTable[i])+"="+str(data[i])+","
                    i = i+1
                logEvent=logEvent[0:len(logEvent)-1]+linesep
                self.esperTCP.send(logEvent)
        except Exception, e:
            logging.error("ERRO: Falha ao enviar dados ao esper: ", exc_info=True)
        
	try:
            eventDB = EventDatabaseConnection()
            db = eventDB.connect()
            collection = db[table]
            
            i = 0
            document = "{"
            while(i <= len(data) - 1):
		try:
		    data[i] = int(data[i])	
                    document = document + '"' + str(formatTable[i]) + '": ' + str(data[i]) + ', '
                except Exception, e:
		    data[i] = data[i].encode('utf-8').replace('"', "'")
                    document = document + '"' + str(formatTable[i]) + '": ' + '"' + str(data[i]) + '", '
                i = i + 1;
            document = document + '"date_pub": "' + str(datetime.now()) + '"}'
#	    jsonDocument = json.loads(document.strip())

#	    decoded_string = document.decode('ascii') 
#	    document = decoded_string.encode('utf8')
	
            collection.insert(ast.literal_eval(document))
            resposta = True                                  
#            i = 0
#            column = ""
#            
#            #=====================================================================================#
#            # Monta as colunas, e posteriormente os dados, para criar a sintaxe do SQL e realizar
#            # a inserção, adicionando ao final a data de publicação
#            while (i <= len(formatTable) - 1):
#                column = column + str(formatTable[i]) + ","
#                i = i + 1;
#            column = column + str('date_pub')
#            #=====================================================================================#    
#            # Monta os dados
#            date_pub = datetime.now()
#            i = 0
#            dados = "'"
#            while (i <= len(data) - 1):
#                dados = dados + str(data[i]) + "','"
#                i = i + 1;
#            dados = dados + str(date_pub) + "'"
#            #=====================================================================================#
#            # Montando SQL
#            sql = "INSERT INTO " + '"' + str(table) + '"' + "(" + str(column) + ") VALUES (" 
#            sql = sql + str(dados) + ")"
#            #=====================================================================================#
#            
#            #=====================================================================================#
#            # Realiza a conexão com o banco de dados
#            dbConnection = DatabaseConnection()
#            con = dbConnection.connect() 
#            cur = con.cursor()
#            #=====================================================================================#
#            
#            #=====================================================================================#
#            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
#            # False), e a retorna para o agente tratar
#            try:
#                cur.execute(sql)
#                con.commit()
#                resposta = True    
#            except Exception, e:
#                logging.error("ERRO: Falha ao inserir dados no banco: ", exc_info=True)
#                logging.error("Consulta SQL com erro: " + sql)
#                resposta = False
#            finally:
#                cur.close()
#                con.close()
#            
            return resposta
            #=====================================================================================#
        except Exception, e:
                logging.error("Falha ao inserir logs no banco", exc_info=True)
		logging.error("Identificador: %s, Tabela: %s, Formato da Tabela: %s, Dados: %s",
				str(identifierHostname), str(table), 
				str(formatTable), str(data))
                return False
        
    def insertSituations(self, table, formatTable, data):
        """
        Função usada para receber os logs analisados e inseri-los em suas respectivas tabelas,
        caso ocorra algum erro, retorna False, este retorno deverá ser tratado no agente.
        """
        try:
            #=====================================================================================#
            # Descriptografa os parâmetros passados (tabela, formato da tabela e data de coleta)
            #table = str(tableEncrypted)
            #formatTable = eval(str(formatTableEncrypted))
            #data = ast.literal_eval(str(dataEncrypted))
                                               
            #=====================================================================================#
            # Monta as colunas, e posteriormente os dados, para criar a sintaxe do SQL e realizar
            # a inserção, adicionando ao final a data de publicação
            #i = 0
            #column = ""
            situationID = data[2]
            description = data[0]
            startDate = self.findFirstDateColl(str(data[1]))
            endDate = self.findLastDateColl(str(data[1]))
            
            #while (i <= len(formatTable) - 1):
            #    column = column + str(formatTable[i]) + ","
            #    if formatTable[i] == 'situationid':
            #        situationID = data[i]
            #    if formatTable[i] == 'description':   
            #        description = data[i]
            #    if formatTable[i] == 'events':
            #        startDate = self.findFirstDateColl(str(data[i]))
            #        endDate = self.findLastDateColl(str(data[i]))
            #    i = i + 1;
            #column = column + str('date_pub')
            
            formatTable.append('date_pub')
            #=====================================================================================#    
            # Monta os dados
            date_pub = datetime.now()
            #i = 0
            #dados = "'"
            #while (i <= len(data) - 1):
            #    dados = dados + str(data[i]) + "','"
            #    i = i + 1;
            #dados = dados + str(date_pub) + "'"
            data.append(str(datetime.now()))
            #=====================================================================================#
            # Montando SQL
            sql = 'SELECT events, occurrences, commandresult FROM "' + table + '" WHERE situationid = %s and description = %s'
	    params = (situationID,  description)
            #=====================================================================================#
            
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            try:
                cur.execute(sql, params)
                con.commit()
                eventOccurrences = cur.fetchall()
                                
                if len(eventOccurrences) == 0:
                    # É a primeira vez que a situação será inserida, logo deve-se identificar nos eventos
                    # o primeiro date_coll e o último para atualizar a data inicial e final da situação
                    #column = column + ",startdate, enddate"
                    formatTable.append('startdate')
                    formatTable.append('enddate')
                    
                    #dados = dados + ",'" + str(startDate) + "', '" + str(endDate) + "'"
                    data.append(str(startDate))
                    data.append(str(endDate))
                    
#                    sql = "INSERT INTO " + '"' + str(table) + '"' + "(" + str(column) + ") VALUES (" \
#                        + str(dados) + ")"

                    sql = 'INSERT INTO "' + str(table) + '" (%s) VALUES (%s)'
                    params = (tuple(formatTable), tuple(data))                       
                                                            
                else:
                    # Como já possui eventos, para situacao encontrada, a data inicial não deve ser 
                    # modificada, e a data final deve ser modificada para a data do último evento
                    # logo deve-se procurar por date_coll ou datecoll de trás para frente
                    #situationID = data[2]
                    #description = data[0]
                    #startDate = self.[findFirstDateColl(str(data[1]))
                    #endDate = self.findLastDateColl(str(data[1]))
                    events = str(data[1]) + '|' + str(eventOccurrences[0][0]) 
                    occurrences = eventOccurrences[0][1] + 1
                    commandresult = str(data[6]) + '|' + str(eventOccurrences[0][2])
                    
                    #i = 0
                    #updatedColumns = ''
                    #while (i < len(data)):
                    #    if str(formatTable[i]) == 'events':
                    #        data[i] = str(data[i]) + '|' + str(eventOccurrences[0][0])
                    #    if str(formatTable[i]) == 'occurrences':
                    #        data[i] = eventOccurrences[0][1] + 1
                    #    if str(formatTable[i]) == 'commandresult':
                    #        data[i] = str(data[i]) + '|' + str(eventOccurrences[0][2])
                    #    updatedColumns = updatedColumns + str(formatTable[i]) + "='" + str(data[i]) + "', "
                    #    i = i + 1
                    #updatedColumns = updatedColumns + "date_pub='" + str(date_pub) + "',\
                    #                 endDate='" + str(endDate) + "'"
                    
                    # Active_Situations: events, commandresult, date_pub, endDate, occurences,                                     
		    # Utilizar tuplas AQUI
                    #sql = 'UPDATE "' +str(table) + '" SET ' + str(updatedColumns) + " WHERE situationid = " + \
                #str(situationID) + " and description = '" + str(description) + "'"
                    
		    sql = 'UPDATE "' +str(table) + '" SET events = %s, commandresult = %s, date_pub = %s, \
		        enddate = %s, occurrences = %s WHERE situationid = %s and description = %s'
		    params = (events, commandresult, date_pub, endDate, occurrences, situationID, description)
                
                cur.execute(sql, params)
                con.commit()
                
                resposta = True    
            except Exception, e:
                logging.error("ERRO: Falha ao inserir dados no banco: ", exc_info=True)
                logging.error("Consulta SQL com erro: " + sql)
                resposta = False
            finally:
                cur.close()
                con.close()
            
            return resposta
            #=====================================================================================#
        except Exception, e:
                logging.error("ERRO: Falha na análise dos dados recebidos: ", exc_info=True)
                logging.error('Dados: ' + str(data) + 'Formato: ' + str(formatTable) + 
                                       "Tabela: " + str(table))
                return False
    
    def findFirstDateColl (self, events):
        try:
            startDatePos = events.find("date_coll") 
            if startDatePos > 0:
                startDatePos = startDatePos + 10
                return events[startDatePos:startDatePos+26]
            else:
                startDatePos = events.find("datecoll")
                if startDatePos > 0:
                    startDatePos = startDatePos + 9
                    return events[startDatePos:startDatePos+26]
                else:
                    return ''
        except Exception, e:
            logging.error("ERRO: Falha ao identificar a data inicial da situação: ", exc_info=True)
            
    def findLastDateColl (self, events):
        try:
            endDatePos = events.rfind("date_coll") 
            if endDatePos > 0:
                endDatePos = endDatePos + 10
                return events[endDatePos:endDatePos+26]
            else:
                endDatePos = events.rfind("datecoll")
                if endDatePos > 0:
                    endDatePos = endDatePos + 9
                    return events[endDatePos:endDatePos+26]
                else:
                    return ''
        except Exception, e:
            logging.error("ERRO: Falha ao identificar a data final da situação: ", exc_info=True)

    def updateStatus (self, identifierHostnameEncrypted, itemidEncrypted, columnEncrypted, dataEncrypted):
        """
        Atualiza os dados recebidos do agente por parâmetro na tabela items_hosts (referente
        aos itens monitorados para cada host) e os insere na tabela de histórico
        """
        try:
            #=====================================================================================#
            # Descriptografa os parâmetros passados
            itemid = str(itemidEncrypted)
            data = eval(str(dataEncrypted))
            column = eval(str(columnEncrypted))
            identifierHostname = str(identifierHostnameEncrypted)
            value = ''
            
            try:
                if self.readConf.correlation:                           
                    statusEvent = "stream="+str(identifierHostname) + ","
                    i = 0
                    while(i<len(column)):
                        if column[i] == 'datecoll':                 
                            statusEvent=statusEvent+str('date_coll')+"="+str(data[i])+","
                        elif column[i] == 'lastvalue':
                            statusEvent=statusEvent+str(column[i])+"="+str(data[i])+","
                        i = i+1                    
                    statusEvent=statusEvent[0:len(statusEvent)-1]+linesep
                    self.esperTCP.send(statusEvent)
        
            except Exception, e:
                logging.error("ERRO: Falha ao enviar dados ao esper: ", exc_info=True)
            
            # Cria a data de publicação
            date_pub = datetime.now()
            
            #=====================================================================================#
            # Monta as colunas com os valores a serem atualizados, para criar a sintaxe do SQL
            # e realizar a atualização, adicionando ao final a data de publicação
            i = 0
            updatedColumns = ''
            errorFound = False
            while (i < len(data)):
                updatedColumns = updatedColumns + str(column[i]) + "='" + str(data[i]) + "', "
                #=================================================================================#
                # Separa a data de coleta e o valor do item, para inserção na tabela de histórico
                # e identifica se ocorreu algum erro ao coletar dado, para que a tabela de
                # histórico não seja atualizada
                if column[i] == "datecoll":
                    datecoll = data[i]
                elif column[i] == "lastvalue":
                    value = data[i]
                elif column[i] == "errmsg" and data[i] != '':
                    errorFound = True
                #=================================================================================#
                i = i + 1;
            updatedColumns = updatedColumns + "datepub='" + str(date_pub) + "'"
            #=====================================================================================#
            
            #=====================================================================================#
            # Montando SQL para atualização
            sqlUpdate = "UPDATE items_hosts SET " + str(updatedColumns) + " WHERE itemid=" + \
                        str(itemid)
            #=====================================================================================#
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            try:
                cur.execute(sqlUpdate)
                con.commit()
                respostaUpdate = True    
            except Exception, e:
                logging.error("ERRO: Falha ao atualizar dados no banco: ", exc_info=True)
                logging.error("Consulta SQL com erro: " + sqlUpdate)
                respostaUpdate = False
            finally:
                cur.close()
                con.close()
            #=====================================================================================#
            
            respostaHistory = True
            #=====================================================================================#
            # Insere na tabela history somente se não ocorreu erro na coleta do dado pelo agente
            # (quando isso ocorre, o campo errmsg da tabela items_hosts deverá ser populado com
            # uma mensagem de erro, passada do agente para o servidor)
            if errorFound == False:
                sqlHistory = "INSERT INTO history (itemid, datecoll, value) VALUES ('" + str(itemid) \
                        + "', '" + str(datecoll) + "', '" + str(value) + "')"
                #=================================================================================#
                # Realiza a conexão com o banco de dados
                dbConnection = DatabaseConnection()
                con = dbConnection.connect() 
                cur = con.cursor()
                #=================================================================================#
                
                #=================================================================================#
                # Executa o SQL criado, atribui a variável respostaHistory o sucesso da execução
                # (True ou False)
                try:
                    cur.execute(sqlHistory)
                    con.commit()
                    respostaHistory = True    
                except Exception, e:
                    logging.error("ERRO: Falha ao inserir dados no banco: ", exc_info=True)
                    logging.error("Consulta SQL com erro: " + sqlHistory)
                    respostaHistory = False
                finally:
                    cur.close()
                    con.close()
            #=====================================================================================#
            
            #=====================================================================================#
            # Verifica se a execução das duas query SQL foram realizadas com sucesso e retorna
            # o resultado total para o agente
            if respostaHistory == True & respostaUpdate == True:
                return True
            else:
                return False
            #=====================================================================================#
            
        except Exception, e:
                logging.error("ERRO: Falha na análise dos dados recebidos: ", exc_info=True)
#                logging.error('Colunas: ' + column + 'Dados: ' + data + 
#                                       "ItemID: " + itemid, '')
                return False
        
    def insertDiscoveredItems (self, itemidEncrypted, keyListNewEncrypted):
        """
        Insere os novos itens a serem monitorados, criados pelo agente, a partir dos itens de
        descoberta
        """
        try:
            #=====================================================================================#
            # Descriptografa os parâmetros passados
            itemid = str(itemidEncrypted)
            keyListNew = eval(str(keyListNewEncrypted))
            
            #=====================================================================================#
            # Montando SQL para verificar quais itens já existem e quais precisam ser criados
            sql = "SELECT name, key_, identifier FROM items_hosts WHERE itemidhosts='" + str(itemid) + "'"
            #=====================================================================================#
            
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            try:
                cur.execute(sql)
                con.commit()
                keyList = cur.fetchall()
            except Exception, e:
                logging.error("ERRO: Falha ao selecionar dados do banco: ", exc_info=True)
                logging.error("Consulta SQL com erro: " + sql)
            finally:
                cur.close()
                con.close()
            #=====================================================================================#            
            iItem = 0
            iNewItem = 0
            toRemoveKeyList = []
            toRemoveKeyListNew = []
            while len(keyList) > iItem:
                while len(keyListNew) > iNewItem:
                    if str(keyList[iItem][1]) == str(keyListNew[iNewItem][1]):
                        toRemoveKeyList.append(iItem)
                        toRemoveKeyListNew.append(iNewItem)
                    iNewItem = iNewItem + 1
                iNewItem = 0
                iItem = iItem + 1
            
            # Oderna os indices a serem removidos em ordem descrescente para não dar erro de index out of range
            toRemoveKeyList.sort()
            toRemoveKeyList.reverse()
            toRemoveKeyListNew.sort()
            toRemoveKeyListNew.reverse()
           
            # Atualiza a lista dos itens a serem removidos
            for remove in toRemoveKeyList:
                keyList.pop(remove)
                
            # Atualiza a lista dos itens a serem criados
            for remove in toRemoveKeyListNew:
                keyListNew.pop(remove)
                                     
            #=====================================================================================#
                    
            # Cria a variável resposta, que é utilizada para informar se um novo item foi criado,
            # caso seja criado novo item, o agente deverá atualizar a lista de itens analisados
            itemsModified = False            
            
            # Avalia se sobrou algum item a ser criado (que ainda não existia) e o cria
            while len(keyListNew) > 0:
                newKey = keyListNew.pop()
                if self.createNewItem(itemid, newKey[0], newKey[1], newKey[2], newKey[3]) == True:
                    itemsModified = True
            
            # Avalia se existe algum item que não deve ser mais monitorado
            while len(keyList) > 0:
                if self.removeItem(itemid, keyList.pop()[1]) == True:
                    itemsModified = True
            
            return itemsModified
            #=====================================================================================#
        except Exception, e:
                logging.error("ERRO: Falha na análise dos dados recebidos: ", exc_info=True)
                logging.error('ItemID: ' + str(itemid) + 'KeyList: ' + str(keyList))
                return False
            
    def createNewSituations(self, itemIDDiscovery, itemIDNew, hostid, valueDiscovered):
        '''
        Verifica se há situações associadas com o item, caso exista, cria
        as novas situações a serem detectadas substituindo o identificador
        na consulta epl        
        '''        
        try:
            #=====================================================================================#
            # Coleta as informações que serão necessárias para criar o novo item.
            sqlSelect = "SELECT * FROM situations_hosts WHERE situationid in (SELECT situationid FROM \
            items_situations_hosts WHERE itemid = '" + itemIDDiscovery + "')"
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável valuesNewItem as informações para criar o
            # novo item
            cur.execute(sqlSelect)
            con.commit()
            valuesToNewSituation = cur.fetchall()

            #=====================================================================================#
            
            #=====================================================================================#
            # Substitui possíveis variáveis, caso não exista a variável, o valor não é alterado
            for newSituation in valuesToNewSituation:
                newEPL = str(newSituation[1]).replace('$IFACE', valueDiscovered)
                newDescription = str(newSituation[0]).replace('$IFACE', valueDiscovered)
                newCommand = str(newSituation[3]).replace('$IFACE', valueDiscovered)
                
                newEPL = str(newSituation[1]).replace('$PARTITION', valueDiscovered)
                newDescription = str(newSituation[0]).replace('$PARTITION', valueDiscovered)
                newCommand = str(newSituation[3]).replace('$PARTITION', valueDiscovered)
                    
                sqlInsert = "INSERT INTO situations_hosts (description, epl, command, commandtype, \
                severity, comments, to_, subject, body, situationhostsid, occurrences) SELECT '" + \
                str(newDescription) + "', '" + str(newEPL) + "', \
                '" + str(newCommand) + "', '" + str(newSituation[4]) + "', '" + \
                str(newSituation[10]) + "', '" + str(newSituation[5]) + "', '" + \
                str(newSituation[7]) + "', '" + str(newSituation[8]) + "', '" + \
                str(newSituation[9]) + "', '" + str(newSituation[10]) + "', '" + \
                str(newSituation[11]) + "' WHERE \
                NOT EXISTS (SELECT epl FROM situations_hosts WHERE epl = '" + str(newEPL) + "')" 
                                
                #=====================================================================================#
                # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
                # False), e a retorna a função insertDiscoverdItems
                cur.execute(sqlInsert)
                con.commit()
                
                sqlSelectSituationID = "SELECT situationid FROM situations_hosts WHERE epl='" + str(newEPL) + "'"
                cur.execute(sqlSelectSituationID)
                con.commit()
                situationIDNew = cur.fetchall()
                
                sqlInsertRelation = "INSERT INTO items_situations_hosts (itemid, situationid, hostid, \
                status, correlation) SELECT '" + str(itemIDNew) + "', '" +  str(situationIDNew[0][0]) + "', '" + \
                str(hostid) + "', '" + str('1') + "', '" + str(1) + "' WHERE NOT EXISTS (SELECT itemid, situationid FROM \
                items_situations_hosts WHERE itemid = '" + str(itemIDNew) + "' and situationid = '" + \
                str(situationIDNew[0][0]) + "')"
                
                cur.execute(sqlInsertRelation)
                con.commit()
            
            return True                           
        except Exception, e:
            logging.error("ERRO: Falha ao inserir nova situação: ", exc_info=True)
            return False
        finally:
            cur.close()
            con.close()            
     
    def createNewItem(self, itemid, name, key, identifier, valueDiscovered):
        """
        Cria os novos itens a serem analisados pelo agente
        """
        try:
            #=====================================================================================#
            # Coleta as informações que serão necessárias para criar o novo item.
            sqlSelect = "SELECT hostid, delay, table_, filterprogram, formatcolumn, formatcolumntype, \
            formatcolumntypedata, formatcolumnname, formatcolumnvisible FROM items_hosts WHERE \
            itemid='" + itemid + "'"
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável valuesNewItem as informações para criar o
            # novo item
            cur.execute(sqlSelect)
            con.commit()
            valuesToNewItem = cur.fetchall()            
            #=====================================================================================#
            valuesToNewItem = [('' if x is None else str(x)) for x in valuesToNewItem[0]]
            #=====================================================================================#
            # Insere o novo item
            sqlInsert = "INSERT INTO items_hosts (hostid, name, key_, delay, status, itemidhosts, table_, \
            filterprogram, formatcolumn, formatcolumntype, formatcolumntypedata, formatcolumnname, \
            formatcolumnvisible, identifier) VALUES ('" + str(valuesToNewItem[0]) + "', '" + str(name) + "', \
            '" + key + "', '" + str(valuesToNewItem[1]) + "', '1', '" + itemid + "', '" + \
            str(valuesToNewItem[2]) + "', '" + str(valuesToNewItem[3]) + "', '" + \
            str(valuesToNewItem[4]) + "', '" + str(valuesToNewItem[5]) + "', '" + \
            str(valuesToNewItem[6]) + "', '" + str(valuesToNewItem[7]) + "', '" + \
            str(valuesToNewItem[8]) + "', '" + identifier + "')"                    
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna a função insertDiscoverdItems
            cur.execute(sqlInsert)
            con.commit()
            resposta = True
            
            sqlSelectItemID = "SELECT itemid FROM items_hosts WHERE key_='" + key + "'"
            cur.execute(sqlSelectItemID)
            con.commit()
            itemIDNew = cur.fetchall()            
                
            resposta = self.createNewSituations(itemid, itemIDNew[0][0], valuesToNewItem[0], valueDiscovered)
                
            return resposta
        except Exception, e:
            logging.error("ERRO: Falha ao inserir novo item: ", exc_info=True)
            logging.error('ItemID: ' + itemid + ', Chave: ' + key)
            return False
        
    def removeItem(self, itemid, key):
        """
        Remove os itens existentes que não deverão mais ser monitorados.
        """
        try:
            #=====================================================================================#
            # Seleciona o itemid dos itens a serem removidos 
            sqlSelect = "SELECT itemid FROM items_hosts WHERE itemidhosts='" + str(itemid) + "' AND key_='" + \
                    str(key) + "'"
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            cur.execute(sqlSelect)
            con.commit()
            itemids = cur.fetchall()
            
            for itemidremove in itemids:
                #=================================================================================#
                # Remover os itens que não devem ser mais monitorados
                sqlDelItem = "DELETE FROM items_hosts WHERE itemid='" + str(itemidremove[0]) + "'"
                cur.execute(sqlDelItem)
                con.commit()
                #=================================================================================#
                
                #=================================================================================#
                sqlDelSituation = "DELETE FROM items_situations_hosts WHERE itemid='" + \
                                    str(itemidremove[0]) + "'"
                cur.execute(sqlDelSituation)
                con.commit()            
                #=================================================================================#
            resposta = True
                
            return resposta
            #=====================================================================================#
        except Exception, e:
            logging.error("ERRO: Falha ao excluir dados do banco: ", exc_info=True)
            logging.error('ItemID: ' + str(itemid) + ', Chave: ' + str(key))
            return False
        finally:
            cur.close()
            con.close()
                   
    def getSymmetricKey(self, clientNameBinary, signatureBinary):
        try:
            #=====================================================================================#
            # Importa a chave pública passada por parâmetro na chamada da função realizada pelo 
            # agente (cliente) para o servidor
            clientName = str(clientNameBinary)
            signature = eval(str(signatureBinary))
            pubKeyClientStored = open('pubKeyClients/' + clientName + '.key').read()
            pubKeyClientStored = RSA.importKey(pubKeyClientStored)
            
            hashToSign = MD5.new(clientName).digest()

            if pubKeyClientStored.verify(hashToSign, signature):
                #=====================================================================================#
                # Criptografa a chave simétrica lida do arquivo de configuração utilizando a chave
                # pública do agente e a retorna ao agente, que irá descriptogrfá-la usando a sua chave
                # privada, para posteriormente iniciar a comunicação através da criptografia por 
                # chave simétrica por questṍes de otimização
                # Random deve ser utilizado caso ocorra a utilização do os.fork() em algumo
                # momento pela aplicação conforme especificação da documentação do PyCrypto
                Random.atfork()
                random_generator = Random.new().read
                symmetricKeyEncrypted = pubKeyClientStored.encrypt(str(self.crypto.getSymmetricKey()), random_generator)
                return str(symmetricKeyEncrypted)
            else:
                return False
            #=====================================================================================#
        except Exception, e:
            logging.error("ERRO: Não foi possível enviar a chave " + 
                                    "simétrica para o agente: ", exc_info=True)
            return False
        
    def getSituations(self, clientNameEncrypted):
        '''
        Coleta as situações de acordo com o nome do cliente.
        '''
        try:
            clientName = str(clientNameEncrypted)
            #=====================================================================================#
            # Montando SQL para remover os itens que não devem ser mais monitorados
	    sqlSituations = "SELECT situations_hosts.situationid, description, epl, comments, command, commandtype, to_, \
            subject, body, severity, identifier, formatcolumntypedata, formatcolumn, criticality, occurrences FROM \
            situations_hosts INNER JOIN items_situations_hosts on situations_hosts.situationid=items_situations_hosts.situationid \
	INNER JOIN items_hosts on items_situations_hosts.itemid = items_hosts.itemid and items_situations_hosts.hostid = items_hosts.hostid \
	INNER JOIN hosts on items_situations_hosts.hostid = hosts.hostid \
      WHERE items_situations_hosts.status=1 and items_situations_hosts.hostid=(SELECT hostid FROM hosts WHERE host='" + str(clientName) +  "');"

#            sqlSituations = "SELECT situationid, description, epl, comments, command, commandtype, to_, \
#            subject, body, severity, identifier, formatcolumntypedata, formatcolumn, criticality, occurrences FROM (SELECT * FROM \
#            (SELECT * FROM situations_hosts join items_situations_hosts USING (situationid) WHERE epl NOT LIKE '%$%') \
#            as situations  join items_hosts using (itemid, hostid) WHERE situationid in (SELECT situationid FROM \
#            items_situations_hosts WHERE hostid= (SELECT hostid FROM hosts WHERE \
#            host='" + str(clientName) +  "') and status=1)) as situations_table join hosts using (hostid)"
            #=====================================================================================#
            
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            
            cur.execute(sqlSituations)
            con.commit()
            confCollect = cur.fetchall()
            
            resposta = confCollect
            #=====================================================================================#
        except Exception, e:
                logging.error("ERRO: Falha ao selecionar situações: ", exc_info=True)
                logging.error("Consulta SQL com erro: " + sqlSituations)
                return False
        finally:
                cur.close()
                con.close()
                return str(resposta)
            
    def getHostOptions(self, clientNameEncrypted):
        '''
        Coleta as opções de acordo no o nome do cliente/
        '''
        try:
            clientName = str(clientNameEncrypted)
            #=====================================================================================#
            # Montando SQL para remover os itens que não devem ser mais monitorados
            sqlOptions = "SELECT correlation FROM hosts WHERE host='" + str(clientName) + "'"
            #=====================================================================================#
            
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            
            cur.execute(sqlOptions)
            con.commit()
            confCollect = cur.fetchall()
            resposta = confCollect
            #=====================================================================================#
        except Exception, e:
                logging.error("ERRO: Falha ao coletar as opções do host: ", exc_info=True)
                logging.error("Consulta SQL com erro: " + sqlOptions)
                return False
        finally:
                cur.close()
                con.close()
                return str(resposta)
            
    def removeSituations(self, clientNameEncrypted, situationIDEncrypted, commentsHistoryEncrypted):
        '''
        Move a situação identificada por seu ID para a tabela history_situations
        adicionando os comentários passados por parâmetro.
        '''
        try:
            clientName = str(clientNameEncrypted)
#             identifier = str(identifierEncrypted)
            situationID = str(situationIDEncrypted)
            commentsHistory = str(commentsHistoryEncrypted)
            #=====================================================================================#
            # Montando SQL para remover as situações que não são mais situações de risco
            sqlSituation = "SELECT * FROM " + str(clientName) + "_active_situations WHERE \
                            situationid=" + str(situationID)
            # e identifier = identifier
            #=====================================================================================#
            
            #=====================================================================================#
            # Realiza a conexão com o banco de dados
            dbConnection = DatabaseConnection()
            con = dbConnection.connect() 
            cur = con.cursor()
            #=====================================================================================#
            
            #=====================================================================================#
            # Executa o SQL criado, atribui a variável resposta o sucesso da execução (True ou 
            # False), e a retorna para o agente tratar
            
            cur.execute(sqlSituation)
            con.commit()
            confCollect = cur.fetchall()
            situation = confCollect
            
            if len(situation) == 1:
		HsqlSituation = "INSERT INTO history_situations (description, events, situationid, \
                date_pub, occurrences, comments, comments_history, priority, commandresult, startdate, \
                enddate) VALUES ('" + str(situation[0][0]) + "','" + str(situation[0][1]) + "'," + \
		situation[0][3] + ",'"+ str(situation[0][5]) + "',"+ situation[0][8] + ",'"+ \
                str(situation[0][9]) + "','"+ str(commentsHistory) + "',"+ situation[0][10] + ",'"+ \
	        str(situation[0][2])+ "','"+ str(situation[0][6])+ "','"+ str(situation[0][7]) + "');"

                cur.execute(sqlHSituation) 

                con.commit()
                
                sqlDelActiveSituation = "DELETE FROM " + str(clientName) + "_active_situations WHERE \
                                        situationid=" + str(situationID)
                                        
                
                                                        
                cur.execute(sqlDelActiveSituation)
                con.commit()
            #=====================================================================================#            
        except Exception, e:
		print "SQLSituacao: " + str(sqlHSituation)
		print "Situacao: " + str(situation[0][3])

                logging.error("ERRO: Falha ao remover situação: ", exc_info=True)
                logging.error("Consulta SQL com erro: " + sqlSituation)
        finally:
                cur.close()
                con.close()
                return True
            
    def connectEsper(self):
        try:
            self.esperTCP.connect(self.esperDest)
            return True
        except Exception:
            return False
        
